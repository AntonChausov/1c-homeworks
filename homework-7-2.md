# Задание к занятию "HTTP-сервисы и SOAP-сервисы"

В качестве результата прислать полную конфигурацию, полученную из всех трех задач - одним файлом.

## Задание 1. Создание схемы данных

Улучшение взаимодействия с сервисом бронирования отелей из занятия 7.1
Как видно из заданий 2 и 3 домашней работы 7.1 - и в варианте JSON и в варианте XML используется одна и та же логическая структура данных:

* Фамилия и имя
* Дата заезда
* Тип номера
* Признак наличия душа
* Признаки приемов пищи (завтрак/обед/ужин), которые включены в стоимость номера

Таким образом, можно структурировать эту модель данных и сделать ее более формальной и удобной для заполнения.

### Описание задачи

Необходимо создать ПакетXDTO с пространством имен "https://netology.ru/1c/data-models/hotels/v1" и описать в нем структуру типов указаннной модели данных.

```
Бронирование
  Гость: Множество элементов типа "Гость"

Гость
  Имя гостя: Строка
  Дата заезда: Дата
  Комната: Комната
    Тип комнаты: перечисление Одиночный/Двойной
    С душем: Булево
  Питание: Питание
    Завтрак: Булево
    Обед: Булево
    Ужин: Булево
```


### Требования к результату

Конфигурация, в пакетах XDTO которой находится пакет "БронированиеОтеля" с указанной структурой.
ПакетXDTO должен позволять сформировать XML требуемой структуры, с правильным именованием узлов и их типом (атрибут, текст, элемент)

### Процесс выполнения

* Создайте чистую конфигурацию
* Создайте ПакетXDTO и назовите его БронированиеОтеля. Задайте пространство имен "https://netology.ru/1c/data-models/hotels/v1"
* Добавьте (из подменю кнопки Добавить) ТипОбъекта и назовите его "Бронирование"
* Повторите для типов-объектов Гость, Комната и Питание
* В типе "Бронирование" создайте свойство "Гость" (правой кнопкой по типу, подменю Добавить/Свойство) и задайте ему тип "Гость" из этого же пространства имен. Обратите внимание, для задания значения свойства нужно сначала "включить" изменения свойства, нажав на кнопку с зеленой галочкой. Наше пространство имен будет в самом низу списка доступных для выбора типов.
* Далее, для свойства Гость задайте "ЛокальноеИмя" равное "guest".
* Также, свойству Гость задайте "МинимальноеКоличество" равное -1 (неограничено) Это превратит свойство Гость в списковое и даст возможность указать несколько гостей в бронировании.
* В **типе объекта** "Гость" добавьте свойство "Имя", укажите ему тип "string (http://www.w3.org/2001/XMLSchema)", форму "Атрибут" и локальное имя "name"
* Добавьте гостю свойство "ДатаЗаезда" с типом "date (http://www.w3.org/2001/XMLSchema)" формой Атрибут и локальным именем "arrives"
* Добавьте гостю свойство "Комната" с типом "Комната (https://netology.ru/1c/data-models/hotels/v1)" и свойство "Питание" с типом "Питание (https://netology.ru/1c/data-models/hotels/v1)" Не забудьте настроить локальные имена "room" и "meals" соответственно.
* В **типе объекта** "Комната" создайте свойства "ТипНомера" и "СДушем". Не забудьте указать локальные имена, т.к. в требуемой схеме они отличаются от названия свойств. Тип - string и boolean соответственно
* В **типе объекта** "Питание" создайте три свойства с типом boolean, назовите Завтрак, Обед, Ужин, задайте локальные имена "brealfast", "dinner", "supper"

Обратите внимание, что задавать локальные имена необязательно. В приниципе, можно было создать схему с англоязычными названиями свойств и типов. В общем и целом, пакеты XDTO часто создают сразу именуя свойства и типы так, как требуется в результирующем XML, но в учебных целях мы рассмотрим ситуацию, когда имена свойств в модели не совпадают с тем, что будет записываться в поток XML. Кроме того, если бы модель имела англоязычные термины, тогда с ней было бы не так удобно работать из языка 1С, постоянно переключая раскладку.

## Задание 2 - сервис бронирования в формате SOAP

### Описание задачи

Конфигурация, принимающая заявки на бронирование по SOAP-протоколу

### Требования к результату

Конфигурация, содержащая веб-сервис и логику сохранения поступившей заявки в базу данных.

### Процесс выполнения

* Создайте метаданные для приема заявок о бронировании:
  * Справочник Гости
  * Документ "Бронирование"
  * Перечисление "ТипКомнаты"
  * Регистр сведений "Бронирования" подчиненный регистратору "Документ.Бронирование" с измерением Гость и ресурсами "ТипКомнаты", "Душ", "Завтрак", "Обед", "Ужин", "ДатаЗаселения"

* Наполните метаданные документа "Бронирование":
  * Табличная часть "Гости" с реквизитами "Гость", "ТипКомнаты", "Душ", "Завтрак", "Обед", "Ужин", "ДатаЗаселения"
  * Напишите алгоритм проведения документа "Бронирование". При проведении документ должен формировать движения в регистре сведений "Бронирования"

* Создайте веб-сервис, принимающий заявки от внешних систем по заданному формату

  * Добавьте в ветку Веб-Сервисы корня метаданных новый веб-сервис "Бронирования", откройте окно редактора веб-сервиса.
  * Укажите пространство имен сервиса (на закладке "прочие") "https://netology.ru/1c/services/hotels/v1" и пакет XDTO "БронированиеОтеля" из задания 1
  * Имя файла публикации (на закладке "прочие") можно указать произвольно, но чтобы оно было информативным. Например, "booking.1cws"
  * На закладке "Операции" редактора веб-сервиса создайте новую операцию и назовите ее "Booking"
  * Добавьте к операции "Booking" параметр операции, назовите его "bookData" и назначьте ему тип "Бронирование" из пространства имен "https://netology.ru/1c/data-models/hotels/v1"
  * Далее, для самой операции Booking нажмите в свойстве "Имя процедуры" кнопку с лупой. Система создаст в модуле веб-сервиса функцию "Booking" с параметром "bookData". Теперь, когда внешняя система будет вызывать нашу систему - именно в этот метод попадет управление, когда надо будет сформировать запись о бронировании. В качестве значения параметра bookData будет передан `ОбъектXDTO` соответствующий типу "Бронирование" из нашего пространства имен.
  * Переименуйте параметр `bookData` в `ДанныеБронирования` для дальнейшего удобства.
  * Сформируйте алгоритм создания и проведения документа "Бронирование" по данным, полученным от внешней системы. В качестве шаблона используйте следующий код:

```bsl
	ДокументБронирование = Документы.Бронирование.СоздатьДокумент();
	ДокументБронирование.Дата = ТекущаяДатаСеанса();
	Для Каждого Гость Из ДанныеБронирования.Гость Цикл
		
		ГостьСсылка = НайтиИлиСоздатьГостя(Гость.Имя);
		СтрокаТЧ = ДокументБронирование.Гости.Добавить();
		СтрокаТЧ.Гость = ГостьСсылка;
		СтрокаТЧ.ДатаЗаселения = Гость.ДатаЗаезда;
		СтрокаТЧ.Душ = Гость.Комната.СДушем;
		Если Гость.Комната.ТипКомнаты = "double" Тогда
			СтрокаТЧ.ТипКомнаты = Перечисления.ТипыНомеров.Двойной;
		Иначе
			СтрокаТЧ.ТипКомнаты = Перечисления.ТипыНомеров.Одиночный;
		КонецЕсли;
		
		СтрокаТЧ.Завтрак = Гость.Питание.Завтрак;
		// и так далеее
		
	КонецЦикла;
	
	Результат = "ОК";
	Попытка
		ДокументБронирование.Записать(РежимЗаписиДокумента.Проведение);
	Исключение
		Результат = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации("Бронирование", УровеньЖурналаРегистрации.Ошибка,,,
			Результат);
	КонецПопытки;
```

Обратите внимание, мы работаем с объектной моделью бронирования из нашего пакета XDTO, обращаясь к ним через точку и используя цикл Для Каждого.

## Задание 3 - HTTP-сервис бронирования

### Описание задачи

Создать параллельный сервис для приемки бронирований по протоколу HTTP. В качестве формата взаимодействия будет использоваться JSON (но мог бы и XML)

### Требование к результату:

Конфигурация из заданий 1 и 2 должна быть дополнена HTTP-сервисом "Бронирования", выполняющим ту же логику.

### Порядок выполнения

* Создайте в ветке метаданных "http-сервисы" новый сервис и назовите его "Бронирования"
* Задайте информативное название свойству "Корневой URL" например hotel. Это будет префикс всех URL-адресов создаваемого сервиса
* На закладке "Шаблоны URL" создайте новый шаблон "Бронирования", в качестве свойства "Шаблон" укажите "bookings"
* Далее в редакторе, добавьте шаблону "Бронирования" новый "Метод" (кнопка добавить метод в редакторе шаблонов URL) Укажите название "Создать" и в палитре свойств задайте ему HTTP-метод POST
* В свойстве "Обработчик" метода "Создать" нажмите кнопку с лупой. Система создаст новый метод для обработки входящего запроса.
* В обработчике реализуйте логику чтения пришедшего JSON текста, которая по данным JSON формирует проведение документа Бронирование. Обратите внимание, что тут не контролируется правильность пришедшего на вход документа, как это было в SOAP (XML) сервисе.
* Используйте следующий шаблон кода:

```bsl
// предполагается, что на вход поступил JSON из задания 7-1-3
Попытка
	
	ТекстJSON = Запрос.ПолучитьТелоКакСтроку();
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТекстJSON);
	
	СтруктураДанных = ПрочитатьJSON(ЧтениеJSON, Ложь);
	ДокументБронирование = Документы.Бронирование.СоздатьДокумент();
	ДокументБронирование.Дата = ТекущаяДатаСеанса();

	Для Каждого Гость Из СтруктураДанных Цикл
		// тут алгоритм разбора массива гостей
	КонецЦикла;
	ДокументБронирование.Записать(РежимЗаписиДокумента.Проведение);
Исключение
	Результат = ОписаниеОшибки();
	ЗаписьЖурналаРегистрации("Бронирование", УровеньЖурналаРегистрации.Ошибка,,,
		Результат);

	Ответ = Новый HTTPСервисОтвет(400);
	Ответ.УстановитьТелоИзСтроки(Результат);
	Возврат Ответ;	
КонецПопытки;

// ВАЖНО - вернуть ответ с успешным кодом 200
Возврат Новый HTTPСервисОтвет(200);
```

